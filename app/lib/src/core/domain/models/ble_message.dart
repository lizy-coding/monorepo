import 'dart:convert';

import 'package:json_annotation/json_annotation.dart';
import 'package:meta/meta.dart';

import 'ble_message_status.dart';
import 'exceptions.dart';

part 'ble_message.g.dart';

/// Default BLE characteristic payload limit in bytes.
const int kDefaultBlePayloadLimit = 180;

/// Encapsulates a single chat message exchanged over BLE.
@immutable
@JsonSerializable()
class BleMessage {
  BleMessage({
    required this.id,
    required this.conversationId,
    required this.senderDeviceId,
    required this.receiverDeviceId,
    required this.payload,
    required this.createdAt,
    this.deliveredAt,
    this.readAt,
  }) {
    _validatePayload(payload);
  }

  /// Unique identifier for the message.
  final String id;

  /// Identifier grouping the message inside a conversation.
  final String conversationId;

  /// Device identifier of the sender.
  final String senderDeviceId;

  /// Device identifier of the receiver.
  final String receiverDeviceId;

  /// UTF-8 encoded textual content.
  final String payload;

  /// Creation timestamp generated by the sender.
  final DateTime createdAt;

  /// Timestamp when the receiving device acknowledged the message.
  final DateTime? deliveredAt;

  /// Timestamp when the receiver marked the message as read.
  final DateTime? readAt;

  /// Builds an instance from a JSON map.
  factory BleMessage.fromJson(Map<String, dynamic> json) =>
      _$BleMessageFromJson(json);

  /// Serialises the message to JSON.
  Map<String, dynamic> toJson() => _$BleMessageToJson(this);

  /// Returns the current status of the message derived from delivery markers.
  BleMessageStatus get status {
    if (readAt != null) {
      return BleMessageStatus.read;
    }
    if (deliveredAt != null) {
      return BleMessageStatus.delivered;
    }
    return BleMessageStatus.pending;
  }

  /// Returns a copy with selective fields replaced.
  BleMessage copyWith({
    String? id,
    String? conversationId,
    String? senderDeviceId,
    String? receiverDeviceId,
    String? payload,
    DateTime? createdAt,
    DateTime? deliveredAt,
    DateTime? readAt,
  }) {
    final newPayload = payload ?? this.payload;
    _validatePayload(newPayload);
    return BleMessage(
      id: id ?? this.id,
      conversationId: conversationId ?? this.conversationId,
      senderDeviceId: senderDeviceId ?? this.senderDeviceId,
      receiverDeviceId: receiverDeviceId ?? this.receiverDeviceId,
      payload: newPayload,
      createdAt: createdAt ?? this.createdAt,
      deliveredAt: deliveredAt ?? this.deliveredAt,
      readAt: readAt ?? this.readAt,
    );
  }

  /// Returns a copy where [deliveredAt] is set to [timestamp].
  BleMessage markDelivered(DateTime timestamp) =>
      copyWith(deliveredAt: timestamp);

  /// Returns a copy where [readAt] is set to [timestamp].
  BleMessage markRead(DateTime timestamp) => copyWith(readAt: timestamp);

  /// Returns the payload converted to UTF-8 bytes.
  List<int> get payloadBytes => utf8.encode(payload);

  /// Ensures the payload meets the BLE transfer restrictions.
  static void _validatePayload(String value) {
    if (value.trim().isEmpty) {
      throw MessagePayloadException('Message payload cannot be empty.');
    }
    final byteLength = utf8.encode(value).length;
    if (byteLength > kDefaultBlePayloadLimit) {
      throw MessagePayloadException(
        'Message payload exceeds the maximum of $kDefaultBlePayloadLimit bytes.',
      );
    }
  }

  @override
  String toString() =>
      'BleMessage(id: $id, conversationId: $conversationId, senderDeviceId: $senderDeviceId, receiverDeviceId: $receiverDeviceId, status: $status)';

  @override
  bool operator ==(Object other) {
    return other is BleMessage &&
        other.id == id &&
        other.conversationId == conversationId &&
        other.senderDeviceId == senderDeviceId &&
        other.receiverDeviceId == receiverDeviceId &&
        other.payload == payload &&
        other.createdAt == createdAt &&
        other.deliveredAt == deliveredAt &&
        other.readAt == readAt;
  }

  @override
  int get hashCode => Object.hash(
        id,
        conversationId,
        senderDeviceId,
        receiverDeviceId,
        payload,
        createdAt,
        deliveredAt,
        readAt,
      );
}

